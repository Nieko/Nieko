<#@ template hostspecific="true" language="C#" debug="true"#>
<#@ import namespace="System.Collections.Generic"#>
<#@ import namespace="System.Linq"#>
<#@ include file="EF.Utility.CS.ttinclude"#>
<#@ output extension=".cs" #>
<#@ assembly name="EnvDTE" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

<#

string DefinitionType = Path.GetFileNameWithoutExtension(this.Host.TemplateFile).Replace(".Mapping", "");
string output = string.Empty;
string oldOutput = string.Empty;
var fileInfo = new FileInfo(this.Host.TemplateFile.Replace(".tt",",cs"));  
if(fileInfo.Exists)
{
	var stream = new StreamReader(fileInfo.FullName);
	oldOutput = stream.ReadToEnd(); 
}

//System.Diagnostics.Debugger.Launch(); 

IServiceProvider serviceProvider = (IServiceProvider)this.Host;
AppDomainSetup domainSetup;
AppDomain executionDomain;
MappingExecutor executor;
Assembly executingAssembly = Assembly.GetExecutingAssembly();
Type detailsType;

domainSetup = new AppDomainSetup();
domainSetup.ApplicationBase = new FileInfo(executingAssembly.Location).Directory.FullName;

executionDomain = AppDomain.CreateDomain("ReflectionDomain", null, domainSetup);
detailsType = executionDomain.Load(Assembly.GetExecutingAssembly().FullName).GetTypes()
	.First(t => t.Name == "MappingExecutor");

executor = (MappingExecutor)executionDomain.CreateInstanceAndUnwrap(Assembly.GetExecutingAssembly().FullName, detailsType.FullName);
executor.ServiceProvider = serviceProvider;

try
{
	var output = executor.Execute(DefinitionType);
}
catch(Exception)
{
	output = oldOutput;
}
finally
{
	AppDomain.Unload(executionDomain);
}

Write(output);

#>
<#+
	
public class MappingExecutor : MarshalByRefObject
{
	public IServiceProvider ServiceProvider;
	
	public string Execute(string typeName)
	{
		System.Reflection.Assembly outputAssembly;
		System.IO.DirectoryInfo outputFolder;
		List<AssemblyName> referencedAssemblies = new List<AssemblyName>();
		List<string> loadedAssemblies = new List<string>();
		List<Assembly> outputAssemblies = new List<Assembly>();
		List<string> typeArgumentNames = new List<string>();
		AssemblyName assemblyName;
		
		EnvDTE.DTE dte = (EnvDTE.DTE) ServiceProvider.GetService(typeof(EnvDTE.DTE));
		EnvDTE.Solution currentSolition = dte.Solution;
		
		string startupProjectName = (string)dte.Solution.Properties
				.Cast<EnvDTE.Property>()
				.First(prop => prop.Name == "StartupProject").Value;
		
		var project = dte.Solution.Projects
			.Cast<EnvDTE.Project>()
			.First(proj => proj == null || proj.Properties == null ? false : proj.Name == startupProjectName);
				
		var debugBuild = project.ConfigurationManager
				.Cast<EnvDTE.Configuration>()
				.First(conf => conf.ConfigurationName == "Debug");
		
		string outputPath = project.Properties.Cast<EnvDTE.Property>().First(p => p.Name == "LocalPath").Value.ToString();

		outputPath += debugBuild.Properties.Cast<EnvDTE.Property>().First(prop => prop.Name == "OutputPath").Value.ToString();
		
		outputFolder = new System.IO.DirectoryInfo(outputPath);
		
		foreach(var file in outputFolder.GetFiles()
			.Where(fileInfo => !fileInfo.Name.Contains("vshost") &&  new string[]{".DLL",".EXE"}
				.Any(ext => ext == fileInfo.Extension.ToUpper())))
		{
			if(loadedAssemblies.Contains(file.FullName))
			{
				continue;
			}
			
			outputAssembly = System.Reflection.Assembly.LoadFrom(file.FullName);
			outputAssemblies.Add(outputAssembly);
			loadedAssemblies.Add(file.Name.Substring(0, file.Name.Length - file.Extension.Length));
		}
		
		referencedAssemblies.AddRange(outputAssemblies.SelectMany(assem => assem.GetReferencedAssemblies()));
		
		while(referencedAssemblies.Count != 0)
		{
			assemblyName = referencedAssemblies[0];
			referencedAssemblies.RemoveAt(0);
			if(loadedAssemblies.Contains(assemblyName.Name))
			{
				continue;
			}
			loadedAssemblies.Add(assemblyName.Name);
			
			foreach(var info in Assembly.Load(assemblyName.FullName).GetReferencedAssemblies())
			{
				if(loadedAssemblies.Contains(info.Name))
				{
					continue;
				}
				referencedAssemblies.Add(info);
			}
		}
		
		Type mappingType = outputAssemblies.SelectMany(assem => assem.GetTypes())
			.FirstOrDefault(t => t.FullName == typeName);
		
		var method = mappingType.GetMethod("Generate");
		
		return (method.Invoke(Activator.CreateInstance(mappingType), null) as string);
	}
}
#>